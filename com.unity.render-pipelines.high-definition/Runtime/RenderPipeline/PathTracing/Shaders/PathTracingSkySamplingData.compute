// Adapted from BuildProbabilityTables.compute

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#define KERNEL_WIDTH 64

// Input(s)
uint4 _Sizes; // xy: Output width, height

// Output(s)
RW_TEXTURE2D(float, PDF);
RW_TEXTURE2D(float, CDF);
RW_TEXTURE2D(float, Marginal);

// Performs a block-level parallel scan.
// Ref: GPU Gems 3, Chapter 39: "Parallel Prefix Sum (Scan) with CUDA".
void ParallelScan(uint i, uint j, uint w, uint iterCount, RW_TEXTURE2D(float, temp), out float sum)
{
    uint offset;

    // Execute the up-sweep phase.
    for (offset = 1; offset <= w / 2; offset *= 2)
    {
        AllMemoryBarrierWithGroupSync();

        for (uint iter = 0; iter < iterCount; iter++)
        {
            uint idx = i + iter * KERNEL_WIDTH;

            // a1 = (2 * i + 1) * offset - 1
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);
            uint a2 = a1 + offset;

            if (a2 < w)
            {
                temp[uint2(a2, j)] += temp[uint2(a1, j)];
            }
        }
    }

    AllMemoryBarrierWithGroupSync();

    // Prevent NaNs arising from the division of 0 by 0.
    sum = max(temp[uint2(w - 1, j)], FLT_EPS);

    AllMemoryBarrierWithGroupSync();

    // The exclusive scan requires the last element to be 0.
    if (i == 0)
    {
        temp[uint2(w - 1, j)] = 0.0;
    }

    // Execute the down-sweep phase.
    for (offset = w / 2; offset > 0; offset /= 2)
    {
        AllMemoryBarrierWithGroupSync();

        for (uint iter = 0; iter < iterCount; iter++)
        {
            uint idx = i + iter * KERNEL_WIDTH;

            // a1 = (2 * i + 1) * offset - 1
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);
            uint a2 = a1 + offset;

            if (a2 < w)
            {
                float t1 = temp[uint2(a1, j)];
                temp[uint2(a1, j)] = temp[uint2(a2, j)];
                temp[uint2(a2, j)] += t1;
            }
        }
    }

    AllMemoryBarrierWithGroupSync();
}

#pragma kernel ComputeConditionalDensities

[numthreads(KERNEL_WIDTH, 1, 1)]
void ComputeConditionalDensities(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint j = dispatchThreadId.y;
    const uint iterCount = _Sizes.x / KERNEL_WIDTH;

    uint iter;

    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        float u = (idx + 0.5) / _Sizes.x;
        float v = (j + 0.5) / _Sizes.y;

        // This mapping is sine-weighted
        float3 dir = TransformGLtoDX(SampleSphereUniform(1.0 - v, 1.0 - u));
        float pdf = Luminance(SampleSkyTexture(dir, 0.0, 0).rgb);

        PDF[uint2(idx, j)] = pdf;
        CDF[uint2(idx, j)] = pdf;
    }

    float rowValSum;

    ParallelScan(i, j, _Sizes.x, iterCount, CDF, rowValSum);

    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        CDF[uint2(idx, j)] /= rowValSum;
    }

    if (i == 0)
    {
        float rowIntegralValue = rowValSum / _Sizes.x;
        Marginal[uint2(j, 0)] = rowIntegralValue;
    }
}

#pragma kernel ComputeMarginalRowDensities

[numthreads(KERNEL_WIDTH, 1, 1)]
void ComputeMarginalRowDensities(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint iterCount = _Sizes.y / KERNEL_WIDTH;

    float rowValSum;

    ParallelScan(i, 0, _Sizes.y, iterCount, Marginal, rowValSum);

    for (uint iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        Marginal[uint2(idx, 0)] /= rowValSum;
    }

    if (i == 0)
    {
        float imgIntegralValue = rowValSum / _Sizes.y;
        Marginal[uint2(0, 0)] = imgIntegralValue;
    }
}

// #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
// #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
// #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

// #pragma kernel KMain

// uint4 _Sizes; // xy: Output width, height

// RW_TEXTURE2D_X(float4, _PathTracingSkySamplingTexture);

// [numthreads(8, 8, 1)]
// void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
// {
//     uint2 texelCoord = dispatchThreadId.xy;

//     // Convert texel coord to world space direction (Y up)
//     float2 uv = (texelCoord + 0.5) / _Sizes.xy;

//     float theta = clamp(1.0 - uv.y, 0.0, 1.0) * PI;
//     float phi = uv.x * TWO_PI;

//     float cosTheta = cos(theta);
//     float sinTheta = sin(theta);
//     float cosPhi = cos(phi);
//     float sinPhi = sin(phi);

//     float jacobian = sinTheta; // * TWO_PI * PI / (_Sizes.x * _Sizes.y);

//     // Fetch corresp. intensity from the sky texture
//     float3 direction = float3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);
// 	float3 color = _EnvLightSkyEnabled ? Luminance(SampleSkyTexture(direction, 0.0, 0).rgb) * jacobian : 0.0;

//     _PathTracingSkySamplingTexture[COORD_TEXTURE2D_X(texelCoord)] = float4(color, 1.0);
// }
