// Adapted from BuildProbabilityTables.compute

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#define KERNEL_WIDTH 64

// Input(s)
uint2 _Sizes; // xy: output width, output height

// Output(s)
RW_TEXTURE2D(float, PDF);
RW_TEXTURE2D(float, CDF);
RW_TEXTURE2D(float, Marginal);

// Performs a block-level parallel scan.
// Ref: GPU Gems 3, Chapter 39: "Parallel Prefix Sum (Scan) with CUDA".
void ParallelScan(uint i, uint j, uint w, uint iterCount, RW_TEXTURE2D(float, temp), out float sum)
{
    uint offset;

    // Execute the up-sweep phase.
    for (offset = 1; offset <= w / 2; offset *= 2)
    {
        AllMemoryBarrierWithGroupSync();

        for (uint iter = 0; iter < iterCount; iter++)
        {
            uint idx = i + iter * KERNEL_WIDTH;

            // a1 = (2 * i + 1) * offset - 1
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);
            uint a2 = a1 + offset;

            if (a2 < w)
            {
                temp[uint2(a2, j)] += temp[uint2(a1, j)];
            }
        }
    }

    AllMemoryBarrierWithGroupSync();

    // Prevent NaNs arising from the division of 0 by 0.
    sum = max(temp[uint2(w - 1, j)], FLT_EPS);

    AllMemoryBarrierWithGroupSync();

    // The exclusive scan requires the last element to be 0.
    if (i == 0)
    {
        temp[uint2(w - 1, j)] = 0.0;
    }

    // Execute the down-sweep phase.
    for (offset = w / 2; offset > 0; offset /= 2)
    {
        AllMemoryBarrierWithGroupSync();

        for (uint iter = 0; iter < iterCount; iter++)
        {
            uint idx = i + iter * KERNEL_WIDTH;

            // a1 = (2 * i + 1) * offset - 1
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);
            uint a2 = a1 + offset;

            if (a2 < w)
            {
                float t1 = temp[uint2(a1, j)];
                temp[uint2(a1, j)] = temp[uint2(a2, j)];
                temp[uint2(a2, j)] += t1;
            }
        }
    }

    AllMemoryBarrierWithGroupSync();
}

float3 MapUVToSkyDirection(float u, float v)
{
    float phi = TWO_PI * (1.0 - u);
    //float cosTheta = cos((1.0 - v) * PI);
    float cosTheta = 2.0 * v - 1.0; // Equiareal variant

    return TransformGLtoDX(SphericalToCartesian(phi, cosTheta));
}

#pragma kernel ComputeCDF

[numthreads(KERNEL_WIDTH, 1, 1)]
void ComputeCDF(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint j = dispatchThreadId.y;
    const uint iterCount = _Sizes.x / KERNEL_WIDTH;

    uint iter;

    float v = (j + 0.5) / _Sizes.y;
    //float sinTheta = sin(v * PI);

    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        float u = (idx + 0.5) / _Sizes.x;

        float3 dir = MapUVToSkyDirection(u, v);
        float pdf = Luminance(SampleSkyTexture(dir, 0.0, 0).rgb);// * sinTheta;

        PDF[uint2(idx, j)] = pdf;
        CDF[uint2(idx, j)] = pdf;
    }

    float rowValSum;

    ParallelScan(i, j, _Sizes.x, iterCount, CDF, rowValSum);

    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        CDF[uint2(idx, j)] /= rowValSum;
    }

    if (i == 0)
    {
        float rowIntegralValue = rowValSum / _Sizes.x;
        Marginal[uint2(j, 0)] = rowIntegralValue;
    }
}

#pragma kernel ComputeMarginal

[numthreads(KERNEL_WIDTH, 1, 1)]
void ComputeMarginal(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint iterCount = _Sizes.y / KERNEL_WIDTH;

    float rowValSum;

    ParallelScan(i, 0, _Sizes.y, iterCount, Marginal, rowValSum);

    for (uint iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        Marginal[uint2(idx, 0)] /= rowValSum;
    }

    if (i == 0)
    {
        float imgIntegralValue = rowValSum / _Sizes.y;
        Marginal[uint2(0, 0)] = imgIntegralValue;
    }
}

#pragma kernel NormalizePDF

[numthreads(8, 8, 1)]
void NormalizePDF(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint j = dispatchThreadId.y;

    // Marginal[0, 0] contains the sum of PDF values divided by texture size (width * height)
    float sum = Marginal[uint2(0, 0)];

    float jacobian = sum > 0.0 ? rcp(sum) / (TWO_PI * PI) : 0.0;

    PDF[uint2(i, j)] *= jacobian;
}
