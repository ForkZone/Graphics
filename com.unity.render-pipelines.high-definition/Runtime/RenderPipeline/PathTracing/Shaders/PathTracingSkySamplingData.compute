// Adapted from BuildProbabilityTables.compute

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

// Input(s)
uint4 _Sizes; // xy: Output width, height

// Output(s)
RW_TEXTURE2D(float, PDF);
RW_TEXTURE2D(float, CDF);

uint2 RowTexCoord(uint i, uint j) { return uint2(i, j); }
uint2 ColTexCoord(uint i, uint j) { return uint2(j, i); }

// Performs a block-level parallel scan.
// Ref: GPU Gems 3, Chapter 39: "Parallel Prefix Sum (Scan) with CUDA".
#define PARALLEL_SCAN(texCoord, i, j, w, iterCount, temp, sum)                  \
{                                                                               \
    uint offset;                                                                \
                                                                                \
    /* Execute the up-sweep phase. */                                           \
    for (offset = 1; offset <= w / 2; offset *= 2)                              \
    {                                                                           \
        AllMemoryBarrierWithGroupSync();                                        \
                                                                                \
        for (uint iter = 0; iter < iterCount; iter++)                           \
        {                                                                       \
            uint idx = i + iter * KERNEL_WIDTH;                                 \
                                                                                \
            /*** a1 = (2 * i + 1) * offset - 1 */                               \
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);                    \
            uint a2 = a1 + offset;                                              \
                                                                                \
            if (a2 < w)                                                         \
            {                                                                   \
                temp[texCoord(a2, j)] += temp[texCoord(a1, j)];                 \
            }                                                                   \
        }                                                                       \
    }                                                                           \
                                                                                \
    AllMemoryBarrierWithGroupSync();                                            \
                                                                                \
    /* Prevent NaNs arising from the division of 0 by 0. */                     \
    sum = max(temp[texCoord(w - 1, j)], FLT_EPS);                               \
                                                                                \
    AllMemoryBarrierWithGroupSync();                                            \
                                                                                \
    /* The exclusive scan requires the last element to be 0. */                 \
    if (i == 0)                                                                 \
    {                                                                           \
        temp[texCoord(w - 1, j)] = 0.0;                                         \
    }                                                                           \
                                                                                \
    /* Execute the down-sweep phase. */                                         \
    for (offset = w / 2; offset > 0; offset /= 2)                               \
    {                                                                           \
        AllMemoryBarrierWithGroupSync();                                        \
                                                                                \
        for (uint iter = 0; iter < iterCount; iter++)                           \
        {                                                                       \
            uint idx = i + iter * KERNEL_WIDTH;                                 \
                                                                                \
            /*** a1 = (2 * i + 1) * offset - 1 */                               \
            uint a1 = Mad24(Mad24(2u, idx, 1u), offset, -1);                    \
            uint a2 = a1 + offset;                                              \
                                                                                \
            if (a2 < w)                                                         \
            {                                                                   \
                float t1 = temp[texCoord(a1, j)];                               \
                temp[texCoord(a1, j)] = temp[texCoord(a2, j)];                  \
                temp[texCoord(a2, j)] += t1;                                    \
            }                                                                   \
        }                                                                       \
    }                                                                           \
                                                                                \
    AllMemoryBarrierWithGroupSync();                                            \
}

#define KERNEL_WIDTH 64

#pragma kernel ComputeConditionalDensities

[numthreads(KERNEL_WIDTH, 1, 1)]
void ComputeConditionalDensities(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = dispatchThreadId.x;
    const uint j = dispatchThreadId.y;
    const uint iterCount = _Sizes.x / KERNEL_WIDTH;

    uint iter;
 
    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        float u = (idx + 0.5) / _Sizes.x;
        float v = (j + 0.5) / _Sizes.y;

        float3 dir = TransformGLtoDX(SampleSphereUniform(1.0 - v, 1.0 - u));
        float pdf = Luminance(SampleSkyTexture(dir, 0.0, 0).rgb);

        PDF[uint2(idx, j)] = pdf;
        CDF[uint2(idx, j)] = pdf;
    }

    float rowValSum;

    PARALLEL_SCAN(RowTexCoord, i, j, _Sizes.x, iterCount, CDF, rowValSum)

    for (iter = 0; iter < iterCount; iter++)
    {
        uint idx = i + iter * KERNEL_WIDTH;
        CDF[uint2(idx, j)] /= rowValSum;
    }

    if (i == 0)
    {
        float rowIntegralValue = rowValSum / _Sizes.x;
        CDF[uint2(i, j)] = rowIntegralValue;
    }
}

#pragma kernel ComputeMarginalRowDensities

[numthreads(1, KERNEL_WIDTH, 1)]
void ComputeMarginalRowDensities(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint i = 0;
    const uint j = dispatchThreadId.y;
    const uint iterCount = _Sizes.y / KERNEL_WIDTH;

    float rowValSum;

    PARALLEL_SCAN(ColTexCoord, j, i, _Sizes.y, iterCount, CDF, rowValSum)

    for (uint iter = 0; iter < iterCount; iter++)
    {
        uint idx = j + iter * KERNEL_WIDTH;
        CDF[uint2(i, idx)] /= rowValSum;
    }

    if (j == 0)
    {
        float imgIntegralValue = rowValSum / _Sizes.y;
        CDF[uint2(i, j)] = imgIntegralValue;
    }
}

// #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
// #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
// #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

// #pragma kernel KMain

// uint4 _Sizes; // xy: Output width, height

// RW_TEXTURE2D_X(float4, _PathTracingSkySamplingTexture);

// [numthreads(8, 8, 1)]
// void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
// {
//     uint2 texelCoord = dispatchThreadId.xy;

//     // Convert texel coord to world space direction (Y up)
//     float2 uv = (texelCoord + 0.5) / _Sizes.xy;

//     float theta = clamp(1.0 - uv.y, 0.0, 1.0) * PI;
//     float phi = uv.x * TWO_PI;

//     float cosTheta = cos(theta);
//     float sinTheta = sin(theta);
//     float cosPhi = cos(phi);
//     float sinPhi = sin(phi);

//     float jacobian = sinTheta; // * TWO_PI * PI / (_Sizes.x * _Sizes.y);

//     // Fetch corresp. intensity from the sky texture
//     float3 direction = float3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);
// 	float3 color = _EnvLightSkyEnabled ? Luminance(SampleSkyTexture(direction, 0.0, 0).rgb) * jacobian : 0.0;

//     _PathTracingSkySamplingTexture[COORD_TEXTURE2D_X(texelCoord)] = float4(color, 1.0);
// }
