#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Hammersley.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel AmbientProbeConvolution KERNEL_NAME=AmbientProbeConvolution
#pragma kernel AmbientProbeConvolutionDiffuse KERNEL_NAME=AmbientProbeConvolutionDiffuse OUTPUT_DIFFUSE
#pragma kernel AmbientProbeConvolutionVolumetric KERNEL_NAME=AmbientProbeConvolutionVolumetric OUTPUT_VOLUMETRIC
#pragma kernel AmbientProbeConvolutionDiffuseVolumetric KERNEL_NAME=AmbientProbeConvolutionDiffuseVolumetric OUTPUT_VOLUMETRIC OUTPUT_DIFFUSE
#pragma kernel AmbientProbeConvolutionNoMip KERNEL_NAME=AmbientProbeConvolutionNoMip NO_MIPS

// Input Cubemap
TEXTURECUBE(_AmbientProbeInputCubemap);
// Output buffer
RWStructuredBuffer<float> _AmbientProbeOutputBuffer;
RWStructuredBuffer<float4> _VolumetricAmbientProbeOutputBuffer;
RWStructuredBuffer<float4> _DiffuseAmbientProbeOutputBuffer;

uniform float4 _FogParameters;

#define _FogDimmer _FogParameters.x
#define _FogAnisotropy _FogParameters.y

// Constants from SetSHEMapConstants function in the Stupid Spherical Harmonics Tricks paper:
// http://www.ppsloan.org/publications/StupidSH36.pdf
//  [SH basis coeff] * [clamped cosine convolution factor]
#define fC0 (rsqrt(PI * 4.0) * rsqrt(PI * 4.0))  // Equivalent (0.282095 * (1.0 / (2.0 * sqrtPI)))
#define fC1 (rsqrt(PI * 4.0 / 3.0) * rsqrt(PI * 3.0)) // Equivalent to (0.488603 * (sqrt ( 3.0) / ( 3.0 * sqrtPI)))
#define fC2 (rsqrt(PI * 4.0 / 15.0) * rsqrt(PI * 64.0 / 15.0)) // Equivalent to (1.092548 * (sqrt (15.0) / ( 8.0 * sqrtPI)))
#define fC3 (rsqrt(PI * 16.0 / 5.0) * rsqrt(PI * 256.0 / 5.0)) // Equivalent to (0.315392 * (sqrt ( 5.0) / (16.0 * sqrtPI)))
#define fC4 (rsqrt(PI * 16.0 / 15.0) * rsqrt(PI * 256.0 / 15.0)) // Equivalent to  (0.546274 * 0.5 * (sqrt (15.0) / ( 8.0 * sqrtPI)))

static const float ConvolveCosineLobeBandFactor[] = { fC0, -fC1, fC1, -fC1, fC2, -fC2, fC3, -fC2, fC4 };

// Constants used to premultiply SH with coefficients to avoid ALUs when sampling.
#define k0  0.28209479177387814347f // {0, 0} : 1/2 * sqrt(1/Pi)
#define k1  0.48860251190291992159f // {1, 0} : 1/2 * sqrt(3/Pi)
#define k2  1.09254843059207907054f // {2,-2} : 1/2 * sqrt(15/Pi)
#define k3  0.31539156525252000603f // {2, 0} : 1/4 * sqrt(5/Pi)
#define k4  0.54627421529603953527f // {2, 2} : 1/4 * sqrt(15/Pi)

static const float ks[] = { k0, -k1, k1, -k1, k2, -k2, k3, -k2, k4 };

// Compute the inverse of SphericalHarmonicsL2::kNormalizationConstants.
// See SetSHEMapConstants() in "Stupid Spherical Harmonics Tricks".
#define c0 0.28209479177387814347f // 1/2  * sqrt(1/Pi)
#define c1 0.32573500793527994772f // 1/3  * sqrt(3/Pi)
#define c2 0.27313710764801976764f // 1/8  * sqrt(15/Pi)
#define c3 0.07884789131313000151f // 1/16 * sqrt(5/Pi)
#define c4 0.13656855382400988382f // 1/16 * sqrt(15/Pi)

static const float invNormConsts[] = { 1 / c0, -1 / c1, 1 / c1, -1 / c1, 1 / c2, -1 / c2, 1 / c3, -1 / c2, 1 / c4 };

#define SAMPLE_COUNT 256
#define SH_COEFF_COUNT 27

#if defined(PLATFORM_SUPPORTS_WAVE_INTRINSICS) && defined(PLATFORM_LANE_COUNT)
    // Allocate space to accumulate all waves result. We need space for each single wavefront (because we can't atomic add floats)
    groupshared float outputSHCoeffsLDS[SH_COEFF_COUNT * SAMPLE_COUNT / PLATFORM_LANE_COUNT];
#else
    // Allocate space for parallel reduction (so half the number of samples.
    groupshared float outputSHCoeffsLDS[SH_COEFF_COUNT * SAMPLE_COUNT / 2];
#endif

void ConvolveZonal(inout float sh[27], float3 zh)
{
    for (int l = 0; l <= 2; l++)
    {
        float n = sqrt((4.0f * PI) / (2 * l + 1));
        float k = zh[l];
        float p = n * k;

        for (int m = -l; m <= l; m++)
        {
            int i = l * (l + 1) + m;

            for (int c = 0; c < 3; c++)
            {
                sh[c * 9 + i] = sh[c * 9 + i ] * p;
            }
        }
    }
}


void PackSH(RWStructuredBuffer<float4> buffer, float sh[27])
{
    // Packs coefficients so that we can use Peter-Pike Sloan's shader code.
    // Does not perform premultiplication with coefficients of SH basis functions.
    // See SetSHEMapConstants() in "Stupid Spherical Harmonics Tricks".
    // Constant + linear
    for (int c = 0; c < 3; c++)

    {
        buffer[c] = float4(sh[c * 9 + 3], sh[c * 9 + 1], sh[c * 9 + 2], sh[c * 9 + 0] - sh[c * 9 + 6]);
    }

    // Quadratic (4/5)
    for (int c = 0; c < 3; c++)
    {
        buffer[3 + c] = float4(sh[c * 9 + 4], sh[c * 9 + 5], sh[c * 9 + 6] * 3.0f, sh[c * 9 + 7]);
    }

    // Quadratic (5)
    buffer[6] = float4(sh[0 * 9 + 8], sh[1 * 9 + 8], sh[2 * 9 + 8], 1.0f);
}

[numthreads(SAMPLE_COUNT, 1, 1)]
void KERNEL_NAME(uint dispatchThreadId : SV_DispatchThreadID)
{
    uint sampleCount = SAMPLE_COUNT;

    // Construct the direction
    float2 u = Hammersley2d(dispatchThreadId, sampleCount);
    float3 n = SampleSphereUniform(u.x, u.y);

#if defined(NO_MIPS)
    // Sample once per thread
    float4 value = SAMPLE_TEXTURECUBE_LOD(_AmbientProbeInputCubemap, s_linear_clamp_sampler, n, 0);
#else
    // Grab the cubemap size
    float2 cubeSize;
    _AmbientProbeInputCubemap.GetDimensions(cubeSize.x, cubeSize.y);

    // Prefiltered importance sampling
    // Use lower MIP-map levels for fetching samples with low probabilities
    // in order to reduce the variance.
    // Ref: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html
    //
    // - OmegaS: Solid angle associated with the sample
    // - OmegaP: Solid angle associated with the texel of the cubemap
    float invOmegaP = (6.0 * cubeSize.x * cubeSize.y) / FOUR_PI;
    float pdf = 1.0 / FOUR_PI; // Solid angle of the sphere is 4*PI
    float omegaS = rcp(sampleCount) * rcp(pdf);
    float mipLevel = 0.5 * log2(omegaS * invOmegaP);

    // Sample once per thread
    float4 value = SAMPLE_TEXTURECUBE_LOD(_AmbientProbeInputCubemap, s_linear_clamp_sampler, n, mipLevel);
#endif

    float outputSHCoeffs[SH_COEFF_COUNT];

    for (int channel = 0; channel < 3; ++channel)
    {
        outputSHCoeffs[channel * 9 + 0] = value[channel];
        outputSHCoeffs[channel * 9 + 1] = -n.y * value[channel];
        outputSHCoeffs[channel * 9 + 2] = n.z * value[channel];
        outputSHCoeffs[channel * 9 + 3] = -n.x * value[channel];
        outputSHCoeffs[channel * 9 + 4] = n.x * n.y * value[channel];
        outputSHCoeffs[channel * 9 + 5] = -n.y * n.z * value[channel];
        outputSHCoeffs[channel * 9 + 6] = (3.0 * n.z * n.z - 1.0) * value[channel];
        outputSHCoeffs[channel * 9 + 7] = -n.x * n.z * value[channel];
        outputSHCoeffs[channel * 9 + 8] = (n.x * n.x - n.y * n.y) * value[channel];
    }

    uint i;
#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS

    // Sum up all threads result and broadcast
    for (i = 0; i < SH_COEFF_COUNT; ++i)
    {
        outputSHCoeffs[i] = WaveActiveSum(outputSHCoeffs[i]);
    }

    // First thread of each wave stores the result in LDS
    uint laneCount = WaveGetLaneCount();
    if (dispatchThreadId % laneCount == 0)
    {
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            uint offset = (dispatchThreadId / laneCount) * SH_COEFF_COUNT;
            outputSHCoeffsLDS[i + offset] = outputSHCoeffs[i];
        }
    }

    GroupMemoryBarrierWithGroupSync();

    // Read back the result to VGPRs to store it to memory at the end
    // First wave intializes the array
    for (i = 0; i < SH_COEFF_COUNT; ++i)
    {
        outputSHCoeffs[i] = outputSHCoeffsLDS[i];
    }

    // Then accumulate remaining waves
    uint waveCount = sampleCount / laneCount;
    for (uint wave = 1; wave < waveCount; ++wave)
    {
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            outputSHCoeffs[i] += outputSHCoeffsLDS[i + wave * SH_COEFF_COUNT];
        }
    }
#else
    // Parallel reduction of all threads result.
    for (uint k = 0; k < FastLog2(SAMPLE_COUNT); ++k)
    {
        // Each loop iteration, even threads store their result in LDS, odd threads sum them up back to local VGPR until all results are summed up.
        if ((dispatchThreadId & ((2 << k) - 1)) == (1 << k))
        {
            uint index = dispatchThreadId >> (k + 1);
            for (uint coeff = 0; coeff < SH_COEFF_COUNT; ++coeff)
            {
                outputSHCoeffsLDS[index * SH_COEFF_COUNT + coeff] = outputSHCoeffs[coeff];
            }
        }

        GroupMemoryBarrierWithGroupSync();

        if ((dispatchThreadId & ((2 << k) - 1)) == 0)
        {
            uint index = dispatchThreadId >> (k + 1);
            for (uint coeff = 0; coeff < SH_COEFF_COUNT; ++coeff)
            {
                outputSHCoeffs[coeff] += outputSHCoeffsLDS[index * SH_COEFF_COUNT + coeff];
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }
#endif

    float weight = 4.0 * PI / (sampleCount);

    // Write to memory and convolution + weighing
    if (dispatchThreadId == 0)
    {
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            _AmbientProbeOutputBuffer[i] = outputSHCoeffs[i] * ConvolveCosineLobeBandFactor[i % 9] * weight;
        }

        float result[27];

#if OUTPUT_DIFFUSE
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            result[i] = _AmbientProbeOutputBuffer[i];
        }

        PackSH(_DiffuseAmbientProbeOutputBuffer, result);
#endif

#if OUTPUT_VOLUMETRIC
        // Following is a shader rewrite of the ambient probe transformation code found in HDRenderPipeline.VolumetricLighting.cs SetPreconvolvedAmbientLightProbe
        // The whole thing can probably be simplified but for the sake of readability it is kept as is for now. Performance should not be an issue as this is executed usually only once.
        // (or very rarely)

        // Undo cosine rescaling and apply fog dimmer.
        // NOTE: In theory we should be able to do directly:
        // result[i] = outputSHCoeffs[i] * weight *_FogDimmer;
        // without cosine convolution
        // But for some reason the inverse constants invNormConsts applied here are not equivalent to ConvolveCosineLobeBandFactor.
        // These constant come from the first C# implementation that this code replace. We probably should investigate why.
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            result[i] = _AmbientProbeOutputBuffer[i] * invNormConsts[i % 9] *_FogDimmer;
        }

        float3 zh;
        GetCornetteShanksPhaseFunction(zh, _FogAnisotropy);
        ConvolveZonal(result, zh);

        // Premultiplies the SH with the polynomial coefficients of SH basis functions,
        // which avoids using any constants during SH evaluation.
        // The resulting evaluation takes the form:
        // (c_0 - c_6) + c_1 y + c_2 z + c_3 x + c_4 x y + c_5 y z + c_6 (3 z^2) + c_7 x z + c_8 (x^2 - y^2)
        for (i = 0; i < SH_COEFF_COUNT; ++i)
        {
            result[i] = result[i] * ks[i % 9];
        }

        PackSH(_VolumetricAmbientProbeOutputBuffer, result);
#endif
    }
}
